<!DOCTYPE html> 
<html lang="en"> 
	<head> 
		<meta charset="UTF-8" />
		<title>Stockheimer</title>
		<link rel="stylesheet" href="styles.css" />
	</head>
	<body>
		<div>
			<canvas id="c"></canvas>
		</div>
	</body>




	<script id="vertex-shader-2d" type="notjs">
		//an attribute will receive data from a buffer
		attribute vec4 my_madeup_position2;
		attribute vec4 my_madeup_position;

		//all shaders have a main function
		void main() {
			//gl_Position is a special variable a vertex shader is responsible for setting
			gl_Position = my_madeup_position2;
			gl_Position = my_madeup_position;
		}
	</script>



	<!-- <script id="fragment-shader-2d" type="notjs">
		//Source: http://glslsandbox.com/e#39726.0

#ifdef GL_ES
precision mediump float;
#endif

// Yuldashev Mahmud Effect took from shaderToy mahmud9935@gmail.com

uniform float time;
uniform vec2 mouse;
uniform vec2 resolution;

float snoise(vec3 uv, float res)
{
    const vec3 s = vec3(1e0, 1e2, 1e3);
    
    uv *= res;
    
    vec3 uv0 = floor(mod(uv, res))*s;
    vec3 uv1 = floor(mod(uv+vec3(1.), res))*s;
    
    vec3 f = fract(uv); f = f*f*(3.0-2.0*f);

    vec4 v = vec4(uv0.x+uv0.y+uv0.z, uv1.x+uv0.y+uv0.z,
                  uv0.x+uv1.y+uv0.z, uv1.x+uv1.y+uv0.z);

    vec4 r = fract(sin(v*1e-1)*1e3);
    float r0 = mix(mix(r.x, r.y, f.x), mix(r.z, r.w, f.x), f.y);
    
    r = fract(sin((v + uv1.z - uv0.z)*1e-1)*1e3);
    float r1 = mix(mix(r.x, r.y, f.x), mix(r.z, r.w, f.x), f.y);
    
    return mix(r0, r1, f.z)*2.-1.;
}

void main( void ) {

    vec2 p = -.5 + gl_FragCoord.xy / resolution.xy;
    p.x *= resolution.x/resolution.y;
    
    float color = 3.0 - (3.*length(2.*p));
    
    vec3 coord = vec3(atan(p.x,p.y)/6.2832+.5, length(p)*.4, .5);
    
    for(int i = 1; i <= 7; i++)
    {
        float power = pow(2.0, float(i));
        color += (1.5 / power) * snoise(coord + vec3(0.,-time*.05, time*.01), power*16.);
    }
    gl_FragColor = vec4( color, pow(max(color,0.),1.)*0.4, pow(max(color,0.),2.)*0.15 , color);
}
	</script> -->

	<script id="fragment-shader-2d" type="notjs">
		//fragment shaders don't have a default precision so we need to pick one. mediump is a good default.
		precision mediump float;

		void main() {
			//gl_FragColor is a special variable a fragment shader is responsible for setting
			gl_FragColor = vec4(1, 0, 0.5, 1); //return reddish purple
		}
	</script>

	<script>
		var canvas = document.querySelector("#c");
		var gl = canvas.getContext("webgl");

		function createShader(gl, type, source) {
			var shader = gl.createShader(type);
			gl.shaderSource(shader, source);
			gl.compileShader(shader);
			var success = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
			if(success) {
				return shader;
			}

			console.log("Error while creating shader");
			console.log(gl.getShaderInfoLog(shader));
			gl.deleteShader(shader);
		}

		function createProgram(gl, vertexShader, fragmentShader) {
			var program = gl.createProgram();
			gl.attachShader(program, vertexShader);
			gl.attachShader(program, fragmentShader);
			gl.linkProgram(program);
			var success = gl.getProgramParameter(program, gl.LINK_STATUS);
			if(success) {
				return program;
			}

			console.log(gl.getProgramInfoLog(program));
			gl.deleteProgram(program);
		}

		function createBufferData() {

		}

		if(!gl) {
			console.log("no webgl for you!");
		}
		else {
			//1) create the vertex and fragment shader
			var vertexShaderSource = document.querySelector("#vertex-shader-2d").text;
			var fragmentShaderSource = document.querySelector("#fragment-shader-2d").text;
			var vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
			var fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);

			//2) create the program
			var program = createProgram(gl, vertexShader, fragmentShader);

			//3) create an attribute for to pass into the program
			var positionAttributeLocation = gl.getAttribLocation(program, "my_madeup_position");
			var positionAttributeLocationTime = gl.getAttribLocation(program, "my_madeup_position2");
			console.log("Attributes:");
			console.log(gl.getContextAttributes());


			console.log(positionAttributeLocation);
			console.log(positionAttributeLocationTime);

			//create a buffer, then bind the position buffer to the array buffer in webgl			
			gl.bindBuffer(gl.ARRAY_BUFFER, gl.createBuffer());

			
			//supply data to the program
			var positions = [
				0, 0,
				0, 0.5,
				0.7, 0,
				-0.25, -0.5,
				0.5, -0.5,
				-0.25, -0.25,
			];
			gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);



			//4) setup webgl to draw to screen space
			//tell webgl how to draw from clip space to screen space
			gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);

			//clear the canvas
			gl.clearColor(0, 0, 0, 0);
			gl.clear(gl.COLOR_BUFFER_BIT);



			//5) tell webgl to use our program (pair of shaders)
			gl.useProgram(program);


			//6) turn the attribute on for the program
			gl.enableVertexAttribArray(positionAttributeLocation);

						


			
			//7) tell the attribute how to get data out of position Buffer (ARRAY_BUFFER)
			// ARRAY_BUFFER will look like this: [0, 0, 0.5, 0.7, 0] except it will be in bytes. So this is to tell HOW to get read the bytes and translate them into something useful.
			var size = 2;			//2 coordinates per iteration
			var type = gl.FLOAT;	//the data is 32 big floats
			var normalize = false;	//don't normalize the data
			var stride = 0;			//0 = move forward size* sizeof(type) each iteration to get the next position
			var offset = 0;			//start at the beginning of the buffer
			gl.vertexAttribPointer(positionAttributeLocation, size, type, normalize, stride, offset);






			//8) FINALLY ask webgl to execute the GLSL program
			
			gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);

			//tell webgl to render
			var primitiveType = gl.TRIANGLES;
			var offset = 0;
			var count = 6;
			gl.drawArrays(primitiveType, offset, count);

			console.log("Attributes:");
			console.log(gl.getContextAttributes());
		}





	</script>
</html>